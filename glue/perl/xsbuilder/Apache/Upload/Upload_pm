use APR::Table;
use APR::Bucket;
use APR::Brigade;
use APR::PerlIO;
use APR::Error;
use Apache::Request;

package Apache::Upload;

# XXX argument wrapper for apreq_xs_upload_make
sub new {
    my ($class, $env, %attrs) = @_;
    my $name  = delete $attrs{name};
    my $value = delete $attrs{value};
    my $file  = delete $attrs{file};

    $name     = delete $attrs{-name}  unless defined $name;
    $value    = delete $attrs{-value} unless defined $value;
    $file     = delete $attrs{-file}  unless defined $name;

    $value = $file unless defined $value;

    die "Usage: Apache::Upload->new($env, name => $name, file=>$file)"
        unless defined $name and defined $file;

    return $class->make($env, $name, $value, $file);
}


sub io {
    tie local (*FH), "Apache::Upload::Brigade", shift->bb;
    return bless *FH{IO}, "Apache::Upload::IO";
}

sub fh {
    my $upload = shift;
    open my $fh, "<", $upload->tempname
        or die "Can't open ", $upload->tempname, ": ", $!;
    binmode $fh;
    return $fh;
}


package Apache::Upload::Error;
push our(@ISA), qw/APR::Error Apache::Upload/;

package Apache::Upload::Table;
push our(@ISA), "APR::Table";
BEGIN {
    my @BAD_METHODS = qw/compress merge overlap/;
    for (@BAD_METHODS) {
        no strict;
        next unless my $meth = APR::Table->can($_);
        *{$_} = sub {die __PACKAGE__ ."::",  "$_: unsafe operation"};
    }
}

package Apache::Upload::Brigade;
push our(@ISA), "APR::Brigade";

package Apache::Upload::IO;
push our(@ISA), ();
